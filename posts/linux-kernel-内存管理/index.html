

<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>Linux Kernel 内存管理 - Zhao&#39;s blog</title><meta name="Description" content=""><meta property="og:title" content="Linux Kernel 内存管理" />
<meta property="og:description" content="页内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字（甚至字节），但是，内存管理单元（MMU,管理内存并把虚拟地址转换为" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhzwupup.github.io/blog/posts/linux-kernel-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-20T00:00:00+08:00" />
<meta property="article:modified_time" content="2024-01-20T00:59:35+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux Kernel 内存管理"/>
<meta name="twitter:description" content="页内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字（甚至字节），但是，内存管理单元（MMU,管理内存并把虚拟地址转换为"/>
<meta name="application-name" content="Zhao&#39;s blog">
<meta name="apple-mobile-web-app-title" content="Zhao&#39;s blog">

<meta name="theme-color" content="#f8f8f8"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="https://zhzwupup.github.io/blog/posts/linux-kernel-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" /><link rel="prev" href="https://zhzwupup.github.io/blog/posts/c-c-plus-plus-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C/" /><link rel="next" href="https://zhzwupup.github.io/blog/posts/linux-kernel-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" />
<link rel="stylesheet" href="/blog/css/main.css"><link rel="stylesheet" href="/blog/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/blog/css/color.css"><link rel="stylesheet" href="/blog/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/blog/lib/fontawesome-free/all.min.css">
        <noscript><link rel="stylesheet" href="/blog/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/blog/lib/animate/animate.min.css">
        <noscript><link rel="stylesheet" href="/blog/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Linux Kernel 内存管理",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/zhzwupup.github.io\/blog\/posts\/linux-kernel-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\/"
        },"genre": "posts","wordcount":  4299 ,
        "url": "https:\/\/zhzwupup.github.io\/blog\/posts\/linux-kernel-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\/","datePublished": "2024-01-20T00:00:00+08:00","dateModified": "2024-01-20T00:59:35+08:00","publisher": {
            "@type": "Organization",
            "name": "Zhao"},"author": {
                "@type": "Person",
                "name": "Zhao"
            },"description": ""
    }
    </script><script src="//instant.page/5.2.0" defer type="module" integrity="sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z"></script>
</head>

<body header-desktop="" header-mobile=""><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark'); window.theme = theme;   window.isDark = window.theme !== 'light' }
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('' === 'light' || '' === 'dark' || '' === 'black') setTheme(''), saveTheme(''); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
        window.switchThemeEventSet = new Set()
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/blog/" title="Zhao&#39;s blog">Zhao&#39;s blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/blog/"> Home </a><a class="menu-item" href="/blog/tags/"> Tags </a><a class="menu-item" href="/blog/categories/"> Categories </a><a class="menu-item" href="/blog/about/" title="About"> About </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/blog/" title="Zhao&#39;s blog">Zhao&#39;s blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/blog/" title="">Home</a><a class="menu-item" href="/blog/tags/" title="">Tags</a><a class="menu-item" href="/blog/categories/" title="">Categories</a><a class="menu-item" href="/blog/about/" title="About">About</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content always-active" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#页">页</a></li>
        <li><a href="#区">区</a></li>
        <li><a href="#申请释放页">申请释放页</a></li>
        <li><a href="#kmalloc-和-kfree">kmalloc() 和 kfree()</a></li>
        <li><a href="#slab-层">slab 层</a>
          <ul>
            <li><a href="#slab-层的设计">slab 层的设计</a></li>
            <li><a href="#slab-分配器的接口">slab 分配器的接口</a></li>
            <li><a href="#slab-分配器使用实例">slab 分配器使用实例</a></li>
          </ul>
        </li>
        <li><a href="#内核栈">内核栈</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Linux Kernel 内存管理</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><span class="author fas fa-user-circle fa-fw"></span><a href="/blog/" title="Author" rel=" author" class="author">Zhao</a>
                </span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2024-01-20">2024-01-20</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2024-01-20">2024-01-20</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4299 字&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 9 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#页">页</a></li>
        <li><a href="#区">区</a></li>
        <li><a href="#申请释放页">申请释放页</a></li>
        <li><a href="#kmalloc-和-kfree">kmalloc() 和 kfree()</a></li>
        <li><a href="#slab-层">slab 层</a>
          <ul>
            <li><a href="#slab-层的设计">slab 层的设计</a></li>
            <li><a href="#slab-分配器的接口">slab 分配器的接口</a></li>
            <li><a href="#slab-分配器使用实例">slab 分配器使用实例</a></li>
          </ul>
        </li>
        <li><a href="#内核栈">内核栈</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="页" class="headerLink">
    <a href="#%e9%a1%b5" class="header-mark"></a>页</h2><p>内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字（甚至字节），但是，内存管理单元（MMU,管理内存并把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理。从虚拟内存的角度来看，页就是最小单位。</p>
<p>体系结构不同，支持的页大小也不尽相同，有些体系结构甚至支持几种不同的页大小。大多数 32 位体系结构支持 4KB 的页，而 64 为体系结构一般会支持 8KB 的页。这就意味着，在支持 4KB 页大小并有 1GB 物理内存的机器上，物理内存会被划分为 262144 个页(1*2^30/(4*2^10))。</p>
<p>内核用 struct page 结构体表示系统中的每个物理页，该结构位于 &lt;linux/mm_types.h&gt; 中。该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，它们也可能并不再和同一个 page 结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关的物理页中存放的东需。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。</p>
<p>内核用这一结构来管理系统中所有的页，因为内核需要知道一个页是否空闲（也就是页有没有被分配）。如果页已经被分配，内核还需要知道谁拥有这个页。拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或页高速缓存等。</p>
<blockquote>
<p>系统中的每个物理页都要分配一个这样的结构体，需要多少内存？
假设 struct page 占 40 字节的内存，假定系统的物理页为 8KB 大小，系统有 4GB 物理内存。那么，系统中共有页面 524288 个，描述这么多页面的 page 结构体消耗的内存为 20MB。相对于 4GB 内存而言，只是很小的一部分。</p>
</blockquote>
<h2 id="区" class="headerLink">
    <a href="#%e5%8c%ba" class="header-mark"></a>区</h2><p>由于硬件的限制，内核不能对所有的页一视同仁。有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。所以内核把页划分为不同的区（zone）。内核使用区对具有相似特性的页进行分组。Linux 需要处理如下两种由于硬件存在缺陷而引起的内存寻址问题：</p>
<ul>
<li>一些硬件只能用某些特定的内存地址来执行 DMA（直接内存访问）。</li>
<li>一些体系结构的内存的物理寻址范围比虚拟寻址范围大得多。这样，就有一些内存不能永久地映射到内核空间上。</li>
</ul>
<p>因为存在这些制约条件，Linux 主要使用了四种区：</p>
<ul>
<li>ZONE_DMA, 这个区包含的页能用来执行 DMA 操作。</li>
<li>ZONE_DMA32, 和 ZONE_DMA 相似，该区包含的页面可用来执行 DMA 操作；不同之处在于，这些页面只能被 32 位设备访问。在某些体系结构中，该区将比 ZONE_DMA 更大。</li>
<li>ZONE_NORMAL，这个区包含的都是能正常映射的页。</li>
<li>ZONE_HIGHMEM，这个区包含”高端内存“，其中的页并不能永久地映射到内核地址空间。</li>
</ul>
<p>这些区（还有两种不太重要的）在 &lt;linux/mmzone.h&gt; 中定义。</p>
<p>区的实际使用和分布是与体系结构相关的。例如，某些体系结构在内存的任何地址上执行 DMA 都没有问题。在这些体系结构中，ZONE_DMA 为空，ZONE_NORMAL 就可以直接用于分配。与此相反，在 x86 体系结构中，ISA 设备就不能在整个 32 位的地址空间中执行 DMA，因为 ISA 设备只能访问物理内存的前 16MB。因此，ZONE_DMA 在下 86 上包含的页都在 0-16MB 的内存范围里。</p>
<p>ZONE_HEGHMEM 的工作方式也差不多。能否直接映射取决于体系结构。在 32 位 x86 系统上，ZONE_HIGHMEM 为高于 896MB 的所有物理内存。在其他体系结构上，由于所有内存都被直接映射，所以 ZONE_HIGHMEM 为空。ZONE_HIGHMEM 所在的内存就是所谓的高端内存（high memory）。系统的其余内存就是所谓的低端内存（low memory）。</p>
<p>Linux 把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。例如，ZONE_DMA 内存池让内核有能力为 DMA 分配所需的内存。如果需要这样的内存，那么，内核就可以从 ZONE_DMA 中按照请求的数目取出页。注意， <strong>区的划分没有任何物理意义，只不过是内核为了管理页而采取的一种逻辑上的分组。</strong></p>
<p>某些分配可能需要从特定的区中获取页，而另外一些分配则可以从多个区中获取页。比如，尽管用于 DMA 的内存必须从 ZONE_DMA 中进行分配，但是一般用途的内存却既能从 ZONE_DMA 分配，也能从 ZONE_NORMAL 分配，不过不可能同时从两个区分配，因为分配是不能跨区界限的。</p>
<p>不是所有的体系结构都定义了全部区。</p>
<h2 id="申请释放页" class="headerLink">
    <a href="#%e7%94%b3%e8%af%b7%e9%87%8a%e6%94%be%e9%a1%b5" class="header-mark"></a>申请释放页</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">// &lt;linux/gfp.h&gt;
</span></span><span class="line"><span class="cl">struct page * alloc_pages(gfp_t gfp_mask, unsigned int order);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void __free_pages(struct page *page, unsigned int order);
</span></span><span class="line"><span class="cl">void free_pages(unsigned long addr, unsigned int order);
</span></span><span class="line"><span class="cl">void free_page(unsigned long addr);
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="kmalloc-和-kfree" class="headerLink">
    <a href="#kmalloc-%e5%92%8c-kfree" class="header-mark"></a>kmalloc() 和 kfree()</h2><p>kmalloc() 函数与用户空间的 malloc() 一族函数非常类似，只不过它多了一个 flags 参数。kmalloc() 可以获得以字节为单位的一块内核内存。对于大多数内核分配来说，kmalloc() 比页分配接口函数用得更多。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">// &lt;linux/slab.h&gt;
</span></span><span class="line"><span class="cl">void * kmalloc(size_t size, gfp_t flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void kfree(const void *ptr);
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数返回一个指向内存块的指针，其内存快至少有 size 大小。所分配的内存在物理上是连续的。出错返回 NULL, 除非没有足够的内存可用，否则内核总能分配成功。</p>
<h2 id="slab-层" class="headerLink">
    <a href="#slab-%e5%b1%82" class="header-mark"></a>slab 层</h2><p>分配和释放数据结构是内核中最普遍的操作之一。为了便于数据的频繁分配和回收，变成人员常用到空闲链表。空闲链表包含可供使用的、已经分配好的数据结构块。当代码需要一个新的数据结构实例时，就可以从空闲链表中抓取一个，而不需要分配内存，再把数据放入进去。当不再需要这个数据结构的实例时，就把它放回空闲链表，而不是释放它。从这个意义上说，空闲链表相当于对象高速缓存——快速存储频繁使用的对象类型。</p>
<p>在内核中，空闲链表面临的主要问题之一是不能全局控制。当可用内存变得紧缺时，内核无法通知每个空闲链表，让其收缩缓存的大小以便释放出一些内存。实际上，内核根本就不知道存在任何空闲链表。为了弥补这一缺陷，也为了使代码更加稳固，Linux 内核提供了 slab 曾（也就是所谓的 slab 分配器）。slab 分配器扮演了通用数据结构缓存层的角色。</p>
<p>slab 分配器 试图在几个基本原则之间寻求一种平衡：</p>
<ul>
<li>频繁使用的数据结构也会频繁分配和释放，因此应当缓存它们。</li>
<li>频繁分配和回收必然会导致内存碎片（难以找到大块连续的可用内存）。为了避免这种现象，空闲链表的缓存会连续地存放。因为已释放的数据结构又会放回空闲链表，因此不会导致碎片。</li>
<li>回收的对象可以立即投入下一次分配，因此，对于频繁的分配和释放，空闲链表能够提高其性能。</li>
<li>如果分配器知道对象大小、页大小和总的高速缓存的大小这样的概念，它会做出更明智的决策。</li>
<li>如果让部分缓存专属于单个处理器（对系统上的每个处理器独立且唯一），那么，分配和释放就可以在不加 SMP 锁的情况下进行。</li>
<li>如果分配器是与 NUMA 相关的，它就可以从相同的内存节点为请求者进行分配。</li>
<li>对存放的对象进行着色（color），以防止多个对象映射到相同的高速缓存行（cache line）。</li>
</ul>
<h3 id="slab-层的设计" class="headerLink">
    <a href="#slab-%e5%b1%82%e7%9a%84%e8%ae%be%e8%ae%a1" class="header-mark"></a>slab 层的设计</h3><p>slab 层把不同的对象划分为所谓高速缓存组，其中每个高速缓存组都存放不同类型的对象。每种对象类型对应一个高速缓存。例如，一个高速缓存用于存放进程描述符（task_struct 结构的一个空闲链表），而另一个高速缓存存放索引节点对象（struct inode）。kmalloc() 接口建立在 slab 层之上，使用了一组通用高速缓存。</p>
<p>然后，这些高速缓存被划分为 slab。slab 由一个或多个物理上连续的页组成。一般情况下，slab 仅由一页组成。每个高速缓存可以由多个 slab 组成。</p>
<p>每个 slab 包含一些对象成员，这里的对象即被缓存的数据结构。每个 slab 处于三种状态之一：满、部分满或空。一个满的 slab 没有空闲的对象（所有对象都已被分配）。一个空的 slab 没有分配出任何对象（slab 中的所有对象都是空闲的）。当内核的某一部分需要一个新的对象时，先从部分满的 slab 中进行分配。如果没有部分满的 slab,就从空的 slab 中进行分配。如果没有空的 slab，就要创建一个 slab 了。</p>
<p>每个高速缓存都使用 kmem_cache 结构来表示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">// include/linux/slab_def.h
</span></span><span class="line"><span class="cl">struct kmem_cache {
</span></span><span class="line"><span class="cl">	struct array_cache __percpu *cpu_cache;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* 1) Cache tunables. Protected by slab_mutex */
</span></span><span class="line"><span class="cl">	unsigned int batchcount;
</span></span><span class="line"><span class="cl">	unsigned int limit;
</span></span><span class="line"><span class="cl">	unsigned int shared;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned int size;
</span></span><span class="line"><span class="cl">	struct reciprocal_value reciprocal_buffer_size;
</span></span><span class="line"><span class="cl">/* 2) touched by every alloc &amp; free from the backend */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	slab_flags_t flags;		/* constant flags */
</span></span><span class="line"><span class="cl">	unsigned int num;		/* # of objs per slab */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /*
</span></span><span class="line"><span class="cl">    ......
</span></span><span class="line"><span class="cl">    */
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>slab 分配器通过低级内核页分配器创建新的 slab</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">// mm/slab.c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/*
</span></span><span class="line"><span class="cl"> * Interface to system&#39;s page allocator. No need to hold the
</span></span><span class="line"><span class="cl"> * kmem_cache_node -&gt;list_lock.
</span></span><span class="line"><span class="cl"> *
</span></span><span class="line"><span class="cl"> * If we requested dmaable memory, we will get it. Even if we
</span></span><span class="line"><span class="cl"> * did not request dmaable memory, we might get it, but that
</span></span><span class="line"><span class="cl"> * would be relatively rare and ignorable.
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">static struct page *kmem_getpages(struct kmem_cache *cachep, gfp_t flags,
</span></span><span class="line"><span class="cl">								int nodeid)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	struct page *page;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	flags |= cachep-&gt;allocflags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	page = __alloc_pages_node(nodeid, flags, cachep-&gt;gfporder);
</span></span><span class="line"><span class="cl">	if (!page) {
</span></span><span class="line"><span class="cl">		slab_out_of_memory(cachep, flags, nodeid);
</span></span><span class="line"><span class="cl">		return NULL;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	account_slab_page(page, cachep-&gt;gfporder, cachep);
</span></span><span class="line"><span class="cl">	__SetPageSlab(page);
</span></span><span class="line"><span class="cl">	/* Record if ALLOC_NO_WATERMARKS was set when allocating the slab */
</span></span><span class="line"><span class="cl">	if (sk_memalloc_socks() &amp;&amp; page_is_pfmemalloc(page))
</span></span><span class="line"><span class="cl">		SetPageSlabPfmemalloc(page);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return page;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>slab 分配器释放页</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">// mm/slab.c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/*
</span></span><span class="line"><span class="cl"> * Interface to system&#39;s page release.
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">static void kmem_freepages(struct kmem_cache *cachep, struct page *page)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	int order = cachep-&gt;gfporder;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	BUG_ON(!PageSlab(page));
</span></span><span class="line"><span class="cl">	__ClearPageSlabPfmemalloc(page);
</span></span><span class="line"><span class="cl">	__ClearPageSlab(page);
</span></span><span class="line"><span class="cl">	page_mapcount_reset(page);
</span></span><span class="line"><span class="cl">	page-&gt;mapping = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (current-&gt;reclaim_state)
</span></span><span class="line"><span class="cl">		current-&gt;reclaim_state-&gt;reclaimed_slab += 1 &lt;&lt; order;
</span></span><span class="line"><span class="cl">	unaccount_slab_page(page, order, cachep);
</span></span><span class="line"><span class="cl">	__free_pages(page, order);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>slab 层的关键是避免频繁分配和释放页。slab 层只有当给定的高速缓存不能满足需求才会调用页分配函数。只有在下列情况下才会释放页：当可用内存变得紧缺时，系统试图释放出更多内存以供使用；或当高速缓存显式地 3 被撤销时。</p>
<p>slab 层的管理是在每个高速缓存的基础上，通过提供给整个内核一个简单的接口来完成的。通过接口就可以创建和撤销新的高速缓存，并在高速缓存内分配和释放对象。。高速缓存及其内 slab 的复杂管理完全通过 slab 的内部机制来处理。当创建了一个高速缓存后，slab 层所起的作用就像是一个专用的分配器，可以为具体的对象类型进行分配。</p>
<h3 id="slab-分配器的接口" class="headerLink">
    <a href="#slab-%e5%88%86%e9%85%8d%e5%99%a8%e7%9a%84%e6%8e%a5%e5%8f%a3" class="header-mark"></a>slab 分配器的接口</h3><ul>
<li>
<p>一个新的高速缓存通过一下函数创建：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">      // mm/slab_common.c
</span></span><span class="line"><span class="cl">      /**
</span></span><span class="line"><span class="cl">​      * kmem_cache_create - Create a cache.
</span></span><span class="line"><span class="cl">​      * @name: A string which is used in /proc/slabinfo to identify this cache.
</span></span><span class="line"><span class="cl">​      * @size: The size of objects to be created in this cache.
</span></span><span class="line"><span class="cl">​      * @align: The required alignment for the objects.
</span></span><span class="line"><span class="cl">​      * @flags: SLAB flags
</span></span><span class="line"><span class="cl">​      * @ctor: A constructor for the objects.
</span></span><span class="line"><span class="cl">      *
</span></span><span class="line"><span class="cl">​      * Cannot be called within a interrupt, but can be interrupted.
</span></span><span class="line"><span class="cl">​      * The @ctor is run when new pages are allocated by the cache.
</span></span><span class="line"><span class="cl">      *
</span></span><span class="line"><span class="cl">​      * The flags are
</span></span><span class="line"><span class="cl">      *
</span></span><span class="line"><span class="cl">​      * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)
</span></span><span class="line"><span class="cl">​      * to catch references to uninitialised memory.
</span></span><span class="line"><span class="cl">      *
</span></span><span class="line"><span class="cl">​      * %SLAB_RED_ZONE - Insert `Red` zones around the allocated memory to check
</span></span><span class="line"><span class="cl">​      * for buffer overruns.
</span></span><span class="line"><span class="cl">      *
</span></span><span class="line"><span class="cl">​      * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware
</span></span><span class="line"><span class="cl">​      * cacheline.  This can be beneficial if you&#39;re counting cycles as closely
</span></span><span class="line"><span class="cl">​      * as davem.
</span></span><span class="line"><span class="cl">      *
</span></span><span class="line"><span class="cl">​      * Return: a pointer to the cache on success, NULL on failure.
</span></span><span class="line"><span class="cl">      */
</span></span><span class="line"><span class="cl">      struct kmem_cache *
</span></span><span class="line"><span class="cl">      kmem_cache_create(const char *name, unsigned int size, unsigned int align,
</span></span><span class="line"><span class="cl">              slab_flags_t flags, void (*ctor)(void *))
</span></span><span class="line"><span class="cl">      {
</span></span><span class="line"><span class="cl">          return kmem_cache_create_usercopy(name, size, align, flags, 0, 0,
</span></span><span class="line"><span class="cl">                          ctor);
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      EXPORT_SYMBOL(kmem_cache_create);
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>撤销高速缓存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">      // mm/slab_common.c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      void kmem_cache_destroy(struct kmem_cache *s)
</span></span><span class="line"><span class="cl">      {
</span></span><span class="line"><span class="cl">          int err;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          if (unlikely(!s))
</span></span><span class="line"><span class="cl">              return;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          get_online_cpus();
</span></span><span class="line"><span class="cl">          get_online_mems();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          mutex_lock(&amp;slab_mutex);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          s-&gt;refcount--;
</span></span><span class="line"><span class="cl">          if (s-&gt;refcount)
</span></span><span class="line"><span class="cl">              goto out_unlock;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          err = shutdown_cache(s);
</span></span><span class="line"><span class="cl">          if (err) {
</span></span><span class="line"><span class="cl">              pr_err(&#34;kmem_cache_destroy %s: Slab cache still has objects\n&#34;,
</span></span><span class="line"><span class="cl">                  s-&gt;name);
</span></span><span class="line"><span class="cl">              dump_stack();
</span></span><span class="line"><span class="cl">          }
</span></span><span class="line"><span class="cl">      out_unlock:
</span></span><span class="line"><span class="cl">          mutex_unlock(&amp;slab_mutex);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          put_online_mems();
</span></span><span class="line"><span class="cl">          put_online_cpus();
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      EXPORT_SYMBOL(kmem_cache_destroy);
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>从缓存中分配
返回一个指向对象的指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">    // mm/slab.c
</span></span><span class="line"><span class="cl">    void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>释放对象
将对象返回给原先的 slab。将 cachep 中的对象 objp 标记为空闲。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">    void kmem_cache_free(struct kmem_cache *cachep, void *objp)
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="slab-分配器使用实例" class="headerLink">
    <a href="#slab-%e5%88%86%e9%85%8d%e5%99%a8%e4%bd%bf%e7%94%a8%e5%ae%9e%e4%be%8b" class="header-mark"></a>slab 分配器使用实例</h3><p>例子来自 kernel/fork.c
内核使用一个全局变量存放指向 task_struct 高速缓存的指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">static struct kmem_cache *task_struct_cachep;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在内核初始化期间， <code>fork_init()</code> 中会创建高速缓存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">task_struct_cachep = kmem_cache_create_usercopy(&#34;task_struct&#34;,
</span></span><span class="line"><span class="cl">			arch_task_struct_size, align,
</span></span><span class="line"><span class="cl">			SLAB_PANIC|SLAB_ACCOUNT,
</span></span><span class="line"><span class="cl">            useroffset, usersize, NULL);
</span></span></code></pre></td></tr></table>
</div>
</div><p>每当进程调用 fork() 时，一定会创建一个新的进程描述符。这是在 dup_task_struct() 中完成的，而该函数会被 do_fork() 调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	struct task_struct *tsk;
</span></span><span class="line"><span class="cl">	unsigned long *stack;
</span></span><span class="line"><span class="cl">	struct vm_struct *stack_vm_area __maybe_unused;
</span></span><span class="line"><span class="cl">	int err;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (node == NUMA_NO_NODE)
</span></span><span class="line"><span class="cl">		node = tsk_fork_get_node(orig);
</span></span><span class="line"><span class="cl">	tsk = alloc_task_struct_node(node);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline struct task_struct *alloc_task_struct_node(int node)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	return kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static __always_inline void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t flags, int node)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	return kmem_cache_alloc(s, flags);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>进程执行完后，如果没有子进程在等待的话，它的进程描述符就会被释放，并返回给 task_struct_cachep slab 高速缓存。这是在 free_task_struct() 中执行的（tsk 是现有的进程):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">static inline void free_task_struct(struct task_struct *tsk)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">	kmem_cache_free(task_struct_cachep, tsk);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="内核栈" class="headerLink">
    <a href="#%e5%86%85%e6%a0%b8%e6%a0%88" class="header-mark"></a>内核栈</h2><p>每个进程的内核栈大小既以来体系结构，也与编译时的选项有关。历史上，每个进程都有两页的内核栈。因为 32 位和 64 位体系结构的页面大小分别是 4KB 和 8KB,所以通常它们的内核栈的大小分别是 8KB 和 16KB。</p>
</div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2024-01-20</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share"></div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/blog/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/blog/posts/c-c-plus-plus-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C/" class="prev" rel="prev" title="C/C&#43;&#43;程序的执行"><i class="fas fa-angle-left fa-fw"></i>C/C&#43;&#43;程序的执行</a>
            <a href="/blog/posts/linux-kernel-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="next" rel="next" title="Linux Kernel 虚拟文件系统">Linux Kernel 虚拟文件系统<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.111.3">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreferrer" title="DoIt 0.4.0"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/blog/" target="_blank" rel="noopener noreferrer">Zhao</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/blog/lib/katex/katex.min.css"><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/blog/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/blog/lib/katex/katex.min.js" defer></script><script type="text/javascript" src="/blog/lib/katex/auto-render.min.js" defer></script><script type="text/javascript" src="/blog/js/katex.min.js" defer></script><script type="text/javascript" src="/blog/js/theme.min.js" defer></script></div>
</body>

</html>